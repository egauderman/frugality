using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Data; // for IValueConverter

namespace shopping_compare
{
	public class ColorConverter : IValueConverter
	{
		// Constants:
		public double DOLLAR_COLORINDEX { get { return 0.0; } }
		public double F_COLORINDEX { get { return 0.00000001; } }
		public double R_COLORINDEX { get { return 0.1; } }
		public double U_COLORINDEX { get { return 0.2; } }
		public double G_COLORINDEX { get { return 0.4; } }
		public double A_COLORINDEX { get { return 0.5; } }
		public double L_COLORINDEX { get { return 0.6; } }
		public double I_COLORINDEX { get { return 0.8; } }
		public double T_COLORINDEX { get { return 0.9; } }
		public double Y_COLORINDEX { get { return 1.0; } }

		public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
		{
			// value is the ColorIndex of a CompareItem
			double colorIndex = (double)value;
			if (colorIndex == -1)
			{
				// Return that nice dark gray color
				return "#FF404040";
			}
			else if (colorIndex == 0)
			{
				return "Green";
			}
			else if (colorIndex > 0 && colorIndex <= 1)
			{
				// Normalize the colorIndex to be an integer from zero to 255, then convert that to a two-digit hexadecimal string.
				// Here, colorIndex is in (0,1] (low is cheap, high is expensive).
				colorIndex = 1 - colorIndex;
				// Here, colorIndex is in [0,1) (low is expensive, high is cheap).
				// Set the range of possible values for green:
				const int greenMin = 0x00;
				const int greenRange = 0xDD;
				// Set greenValue to colorIndex, normalized within [greenMin,greenMin+greenRange), and floor it:
				int greenValue = (int)(colorIndex * greenRange) + greenMin;
				// Here, greenValue is in [greenMin,greenMin+greenRange) (low is expensive, high is cheap).
				// Ensure that greenValue isn't out of the range of a byte:
				if (greenValue >= 256) greenValue = 255;
				// Here, colorValue is an integer in [0,256) (low is expensive, high is cheap).
				// Convert greenValue to a string-formatted hex color code:
				return
					"#FF" + // opacity
					"FF" + // red
					BitConverter.ToString(new byte[] { (byte)greenValue }) + // green // Note: add ".Replace("-", "")" after the string generated by BitConverter if there is more than one byte in the array.
					"00"; // blue
			}
			else
			{
				throw new ArgumentOutOfRangeException("value");
			}
		}

		// Not implemented:
		public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
		{
			throw new NotImplementedException();
		}
	}
}
